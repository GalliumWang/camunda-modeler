{"version":3,"sources":["webpack:///C:/workspace/camunda/camunda-bpmn-js/node_modules/diagram-js/lib/util/Collections.js","webpack:///C:/workspace/camunda/camunda-bpmn-js/node_modules/camunda-bpmn-moddle/lib/index.js","webpack:///C:/workspace/camunda/camunda-bpmn-js/node_modules/camunda-bpmn-moddle/lib/CopyPasteBehavior.js","webpack:///C:/workspace/camunda/camunda-bpmn-js/node_modules/camunda-bpmn-moddle/lib/CopyPasteRootElementBehavior.js","webpack:///C:/workspace/camunda/camunda-bpmn-js/node_modules/camunda-bpmn-moddle/lib/RemoveInitiatorBehaviour.js","webpack:///C:/workspace/camunda/camunda-bpmn-js/node_modules/camunda-bpmn-moddle/lib/RemoveVariableEventBehaviour.js"],"names":["remove","collection","element","idx","indexOf","splice","add","currentIdx","push","module","exports","__init__","camundaCopyPasteBehavior","camundaCopyPasteRootElementBehavior","camundaRemoveInitiatorBehaviour","camundaRemoveVariableEventBehaviour","isFunction","isObject","some","CopyPasteBehavior","eventBus","self","this","on","context","property","parent","canCopyProperty","is","type","$instanceOf","isAny","types","t","getParent","$parent","$inject","prototype","descriptor","$type","$model","getTypeDescriptor","allowedIn","meta","isWildcard","isAllowedInParent","canHostInputOutput","canHostConnector","canHostIn","flowNode","get","inherits","find","matchPattern","CommandInterceptor","default","collectionAdd","collectionRemove","getBusinessObject","CopyPasteRootElementBehavior","bpmnjs","injector","moddleCopy","bpmnFactory","hasRootElement","rootElement","rootElements","getDefinitions","id","invoke","executed","shape","businessObject","canHaveNestedRootElementReference","referencedRootElements","getRootElements","getReferencingElement","addedRootElements","forEach","reference","referencedElement","reverted","addedRootElement","length","index","extensionElement","copyElement","create","values","set","getRootElementReferencePropertyName","bo","extensionElementType","rootElementReference","extensionElements","filteredExtensionElements","filter","reduce","result","findExtensionElement","RemoveInitiatorBehaviour","modeling","postExecuted","newParent","undefined","updateProperties","RemoveVariableEventBehaviour","eventDefinitions","definitionsCopy","newParentBusinessObject","shapeBusinessObject","update","slice","eventDefinition","newDefinition","variableEvents"],"mappings":"2FAQO,SAASA,EAAOC,EAAYC,GAEjC,IAAKD,IAAeC,EAClB,OAAQ,EAGV,IAAIC,EAAMF,EAAWG,QAAQF,GAM7B,OAJa,IAATC,GACFF,EAAWI,OAAOF,EAAK,GAGlBA,EAWF,SAASG,EAAIL,EAAYC,EAASC,GAEvC,GAAKF,GAAeC,EAApB,CAImB,iBAARC,IACTA,GAAO,GAGT,IAAII,EAAaN,EAAWG,QAAQF,GAEpC,IAAoB,IAAhBK,EAAmB,CAErB,GAAIA,IAAeJ,EAGjB,OAGA,IAAa,IAATA,EAOF,OAJAF,EAAWI,OAAOE,EAAY,IASvB,IAATJ,EAGFF,EAAWI,OAAOF,EAAK,EAAGD,GAI1BD,EAAWO,KAAKN,IAcb,SAASE,EAAQH,EAAYC,GAElC,OAAKD,GAAeC,EAIbD,EAAWG,QAAQF,IAHhB,EAvFZ,2H,moVCEAO,EAAOC,QAAU,CACfC,SAAU,CACR,2BACA,sCACA,kCACA,uCAEFC,yBAA0B,CAAE,OAAQ,EAAQ,MAC5CC,oCAAqC,CAAE,OAAQ,EAAQ,MACvDC,gCAAiC,CAAC,OAAQ,EAAQ,MAClDC,oCAAqC,CAAC,OAAQ,EAAQ,Q,iCCVxD,IAAIC,EAAa,EAAQ,KAAYA,WACjCC,EAAW,EAAQ,KAAYA,SAC/BC,EAAO,EAAQ,KAAYA,KAK/B,SAASC,EAAkBC,GAEzB,IAAIC,EAAOC,KAEXF,EAASG,GAAG,8BAA8B,SAASC,GACjD,IAAIC,EAAWD,EAAQC,SACnBC,EAASF,EAAQE,OAErB,OAAOL,EAAKM,gBAAgBF,EAAUC,MAqG1C,SAASE,EAAG1B,EAAS2B,GACnB,OAAO3B,GAAWc,EAAWd,EAAQ4B,cAAgB5B,EAAQ4B,YAAYD,GAG3E,SAASE,EAAM7B,EAAS8B,GACtB,OAAOd,EAAKc,GAAO,SAASC,GAC1B,OAAOL,EAAG1B,EAAS+B,MAIvB,SAASC,EAAUhC,EAAS2B,GAC1B,OAAKA,EAIDD,EAAG1B,EAAS2B,GACP3B,EAGJA,EAAQiC,QAIND,EAAUhC,EAAQiC,QAASN,QAJlC,EAPS3B,EAAQiC,QA7GnBhB,EAAkBiB,QAAU,CAAE,YAK9BjB,EAAkBkB,UAAUV,gBAAkB,SAASF,EAAUC,GAG/D,QAAIT,EAASQ,KAmHf,SAA2BA,EAAUC,GAGnC,IAAIY,EAAab,EAASc,OAASd,EAASe,OAAOC,kBAAkBhB,EAASc,OAE1EG,EAAYJ,GAAcA,EAAWK,MAAQL,EAAWK,KAAKD,UAEjE,IAAKA,GAUP,SAAoBA,GAClB,OAAwC,IAAjCA,EAAUtC,QA5JJ,KAiJKwC,CAAWF,GAC3B,OAAO,EAIT,OAAOxB,EAAKwB,GAAW,SAASb,GAC9B,OAAOK,EAAUR,EAAQG,MAhIAgB,CAAkBpB,EAAUC,QAOnDE,EAAGH,EAAU,yBAA2BH,KAAKwB,mBAAmBpB,QAIhEK,EAAMN,EAAU,CAAE,oBAAqB,oBAAuBH,KAAKyB,iBAAiBrB,QAIpFE,EAAGH,EAAU,gBAAkBH,KAAK0B,UAAUtB,UAAlD,MAKFP,EAAkBkB,UAAUS,mBAAqB,SAASpB,GAKxD,GAFgBQ,EAAUR,EAAQ,qBAGhC,OAAO,EAIT,IAAIuB,EAAWf,EAAUR,EAAQ,iBAEjC,QAAKuB,KAIDlB,EAAMkB,EAAU,CAAE,kBAAmB,eAAgB,0BAIrDrB,EAAGqB,EAAU,qBAAsBA,EAASC,IAAI,uBAOtD/B,EAAkBkB,UAAUU,iBAAmB,SAASrB,GAItD,OAAIE,EAFkBM,EAAUR,EAAQ,2BAEhB,iCAIpBQ,EAAUR,EAAQ,gCAClBQ,EAAUR,EAAQ,mBAOxBP,EAAkBkB,UAAUW,UAAY,SAAStB,GAI/C,QAFmBQ,EAAUR,EAAQ,wBAMTQ,EAAUR,EAAQ,gCAM1CQ,EAAUR,EAAQ,gCAClBQ,EAAUR,EAAQ,oBAOxBjB,EAAOC,QAAUS,G,iCChHjB,IAAIgC,EAAW,EAAQ,KAEnBC,EAAO,EAAQ,KAAYA,KAC3BC,EAAe,EAAQ,KAAYA,aAEnCC,EAAqB,EAAQ,KAA6CC,QAE1EC,EAAgB,EAAQ,KAAmClD,IAC3DmD,EAAmB,EAAQ,KAAmCzD,OAE9D0D,EAAoB,EAAQ,KAA8BA,kBAC1D9B,EAAK,EAAQ,KAA8BA,GAS/C,SAAS+B,EACLC,EAAQxC,EAAUyC,EAAUC,EAAYC,GAM1C,SAASC,EAAeC,GACtB,IACIC,EADcN,EAAOO,iBACMjB,IAAI,gBAEnC,QAASE,EAAKc,EAAcb,EAAa,CAAEe,GAAIH,EAAYG,MAP7DP,EAASQ,OAAOf,EAAoBhC,MAYpCA,KAAKgD,SAAS,gBAAgB,SAAS9C,GAErC,IAAI+C,EAAQ/C,EAAQ+C,MAChBC,EAAiBd,EAAkBa,GAEvC,GAAKE,EAAkCD,GAAvC,CAIA,IAAIE,EAAyBC,EAAgBH,EAAgBI,EAAsBL,IAC/EL,EAAeN,EAAOO,iBAAiBjB,IAAI,gBAE/C1B,EAAQqD,kBAAoB,GAE5BH,EAAuBI,SAAQ,SAASC,GACtC,IAAI7E,EAAU6E,EAAUC,kBAEpB9E,IAAY8D,EAAe9D,KAG7BsD,EAAcU,EAAchE,GAE5BsB,EAAQqD,kBAAkBrE,KAAKN,WAGlC,GAEHoB,KAAK2D,SAAS,gBAAgB,SAASzD,GACrC,IAAIqD,EAAoBrD,EAAQqD,kBAEhC,GAAKA,EAAL,CAIA,IAAIX,EAAeN,EAAOO,iBAAiBjB,IAAI,gBAG/C2B,EAAkBC,SAAQ,SAASI,GACjCzB,EAAiBS,EAAcgB,UAEhC,GAEH9D,EAASG,GAAG,yBAAyB,SAASC,GAC5C,IAAIc,EAAad,EAAQc,WACrBpC,EAAUsB,EAAQtB,QAClBsE,EAAiBd,EAAkBxD,GAEvC,GAAKuE,EAAkCD,GAAvC,CAIA,IAAIN,EAAeS,EAAgBH,EAAgBI,EAAsB1E,IAErEgE,IACF5B,EAAWoC,uBAAyBR,OAKxC9C,EAASG,GAAG,yBAlFK,KAkFmC,SAASC,GAC3D,IAAIc,EAAad,EAAQc,WACrBkC,EAAiBlC,EAAWkC,eAEhC,GAAKC,EAAkCD,GAAvC,CAIA,IAAIE,EAAyBpC,EAAWoC,uBAEpCA,GAA0BA,EAAuBS,QAEnDT,EAAuBI,SAAQ,SAASC,GAEtC,IAmGoBd,EAAamB,EACnCC,EApGMnF,EAAU6E,EAAUC,kBACpB7E,EAAM4E,EAAU5E,IAEfD,IAIA8D,EAAe9D,KAClBA,EAAU4D,EAAWwB,YACnBpF,EACA6D,EAAYwB,OAAOrF,EAAQqC,SAyFX0B,EArFW/D,EAqFEkF,EArFOjF,GAsF1CkF,EAtFiBb,EAsFKtB,IAAI,qBAAqBsC,OAAOJ,IAEzCK,IAAIC,EAAoCL,GAAmBpB,cApFnE3B,EAAWoC,2BAmBtB,SAASE,EAAsB1E,GAC7B,GAAI0B,EAAG1B,EAAS,oBACd,MAAO,+BAIX,SAASwF,EAAoCC,GAC3C,GAAI/D,EAAG+D,EAAI,gCACT,MAAO,WAIX,SAASlB,EAAkCkB,GAEzC,OAD4B/D,EAAG+D,EAAI,qBAAmC,aAAZA,EAAG9D,KAqB/D,SAAS8C,EAAgBgB,EAAIC,GAC3B,IAEIC,EAFAC,EAAoBH,EAAGzC,IAAI,qBAC3B6C,EAA4B,GAuBhC,OApBID,IACFC,EAA4BD,EAAkBN,OAAOQ,QAAO,SAAS9F,GACnE,OAAO0B,EAAG1B,EAAS0F,OAIJG,EAA0BE,QAAO,SAASC,EAAQhG,GAWnE,OATA2F,EAAuB3F,EAAQwF,EAAoCxF,MAGjEgG,EAAO1F,KAAK,CACVL,IAAKgG,EAAqBR,EAAIzF,GAC9B8E,kBAAmBa,IAIhBK,IACN,IAWL,SAASC,EAAqBR,EAAIN,GAChC,IAAIS,EAAoBH,EAAGzC,IAAI,qBAE/B,OAAK4C,EAIEA,EAAkBN,OAAOpF,QAAQiF,IAH9B,EAvFZ1B,EAA6BvB,QAAU,CACrC,SACA,WACA,WACA,aACA,eAGFe,EAASQ,EAA8BL,GAEvC7C,EAAOC,QAAUiD,G,iCC7IjB,IAAIR,EAAW,EAAQ,KAEnBG,EAAqB,EAAQ,KAA6CC,QAC1E3B,EAAK,EAAQ,KAA8BA,GAC3C8B,EAAoB,EAAQ,KAA8BA,kBAK9D,SAAS0C,EACLC,EAAUxC,GAGZA,EAASQ,OAAOf,EAAoBhC,MAEpCA,KAAKgF,aAAa,CAAC,eAAe,eAAe,SAAS9E,GAExD,IAAI+C,EAAQ/C,EAAQ+C,MAChBgC,EAAY/E,EAAQ+E,WAAa/E,EAAQE,OACzC8C,EAAiBd,EAAkBa,GAGnC3C,EAAG2C,EAAO,yBAAkEiC,IAA5ChC,EAAetB,IAAI,sBAGhDtB,EAAG2E,EAAW,oBAGjBF,EAASI,iBAAiBlC,EAAO,CAAE,yBAAqBiC,OAK3D,GAGLJ,EAAyBhE,QAAU,CACjC,WACA,YAGFe,EAASiD,EAA0B9C,GAEnC7C,EAAOC,QAAU0F,G,iCC3CjB,IAAIjD,EAAW,EAAQ,KAEnBG,EAAqB,EAAQ,KAA6CC,QAC1E3B,EAAK,EAAQ,KAA8BA,GAC3C8B,EAAoB,EAAQ,KAA8BA,kBAK9D,SAASgD,EACLL,EAAUxC,EAAUE,EAAaD,GAEnCD,EAASQ,OAAOf,EAAoBhC,MAEpCA,KAAKgF,aAAa,CAAC,aAAc,iBAAiB,SAAS9E,GAEzD,IAIImF,EAAkBC,EAJlBL,EAAY/E,EAAQ+E,WAAa/E,EAAQE,OACzCmF,EAA0BnD,EAAkB6C,GAC5ChC,EAAQ/C,EAAQ+C,MAChBuC,EAAsBpD,EAAkBa,GAGxCwC,GAAS,EAETnF,EAAG2C,EAAO,qBAEN3C,EAAG2E,EAAW,oBAAsBM,EAAwB3D,IAAI,sBAEpEyD,EAAmBG,EAAoB5D,IAAI,qBAC3C0D,EAAkBD,EAAiBK,SAEnBlC,SAAQ,SAASmC,EAAiB7B,GAChD,GAAKxD,EAAGqF,EAAiB,oCAIrBA,EAAgB/D,IAAI,0BAA2B,CACjD6D,GAAS,EAET,IAAIG,EAAgBnD,EAAYwB,OAAO,mCACvCzB,EAAWwB,YAAY2B,EAAiBC,GACxCA,EAAc/E,QAAU8E,EAAgB9E,QAGxC+E,EAAcC,oBAAiBX,EAC/BI,EAAgBxB,GAAS8B,MAIzBH,GACFV,EAASI,iBAAiBlC,EAAO,CAAE,iBAAoBqC,SAI5D,GAGLF,EAA6BtE,QAAU,CACrC,WACA,WACA,cACA,cAGFe,EAASuD,EAA8BpD,GAEvC7C,EAAOC,QAAUgG","file":"14.14.js","sourcesContent":["/**\n * Failsafe remove an element from a collection\n *\n * @param  {Array<Object>} [collection]\n * @param  {Object} [element]\n *\n * @return {number} the previous index of the element\n */\nexport function remove(collection, element) {\n\n  if (!collection || !element) {\n    return -1;\n  }\n\n  var idx = collection.indexOf(element);\n\n  if (idx !== -1) {\n    collection.splice(idx, 1);\n  }\n\n  return idx;\n}\n\n/**\n * Fail save add an element to the given connection, ensuring\n * it does not yet exist.\n *\n * @param {Array<Object>} collection\n * @param {Object} element\n * @param {number} idx\n */\nexport function add(collection, element, idx) {\n\n  if (!collection || !element) {\n    return;\n  }\n\n  if (typeof idx !== 'number') {\n    idx = -1;\n  }\n\n  var currentIdx = collection.indexOf(element);\n\n  if (currentIdx !== -1) {\n\n    if (currentIdx === idx) {\n\n      // nothing to do, position has not changed\n      return;\n    } else {\n\n      if (idx !== -1) {\n\n        // remove from current position\n        collection.splice(currentIdx, 1);\n      } else {\n\n        // already exists in collection\n        return;\n      }\n    }\n  }\n\n  if (idx !== -1) {\n\n    // insert at specified position\n    collection.splice(idx, 0, element);\n  } else {\n\n    // push to end\n    collection.push(element);\n  }\n}\n\n\n/**\n * Fail save get the index of an element in a collection.\n *\n * @param {Array<Object>} collection\n * @param {Object} element\n *\n * @return {number} the index or -1 if collection or element do\n *                  not exist or the element is not contained.\n */\nexport function indexOf(collection, element) {\n\n  if (!collection || !element) {\n    return -1;\n  }\n\n  return collection.indexOf(element);\n}\n","'use strict';\r\n\r\nmodule.exports = {\r\n  __init__: [\r\n    'camundaCopyPasteBehavior',\r\n    'camundaCopyPasteRootElementBehavior',\r\n    'camundaRemoveInitiatorBehaviour',\r\n    'camundaRemoveVariableEventBehaviour'\r\n  ],\r\n  camundaCopyPasteBehavior: [ 'type', require('./CopyPasteBehavior') ],\r\n  camundaCopyPasteRootElementBehavior: [ 'type', require('./CopyPasteRootElementBehavior') ],\r\n  camundaRemoveInitiatorBehaviour: ['type', require('./RemoveInitiatorBehaviour') ],\r\n  camundaRemoveVariableEventBehaviour: ['type', require('./RemoveVariableEventBehaviour') ]\r\n\r\n};\r\n","'use strict';\n\nvar isFunction = require('min-dash').isFunction,\n    isObject = require('min-dash').isObject,\n    some = require('min-dash').some;\n\nvar WILDCARD = '*';\n\n\nfunction CopyPasteBehavior(eventBus) {\n\n  var self = this;\n\n  eventBus.on('moddleCopy.canCopyProperty', function(context) {\n    var property = context.property,\n        parent = context.parent;\n\n    return self.canCopyProperty(property, parent);\n  });\n}\n\nCopyPasteBehavior.$inject = [ 'eventBus' ];\n\n/**\n * Check wether to disallow copying property.\n */\nCopyPasteBehavior.prototype.canCopyProperty = function(property, parent) {\n\n  // (1) check wether property is allowed in parent\n  if (isObject(property) && !isAllowedInParent(property, parent)) {\n\n    return false;\n  }\n\n  // (2) check more complex scenarios\n\n  if (is(property, 'camunda:InputOutput') && !this.canHostInputOutput(parent)) {\n    return false;\n  }\n\n  if (isAny(property, [ 'camunda:Connector', 'camunda:Field' ]) && !this.canHostConnector(parent)) {\n    return false;\n  }\n\n  if (is(property, 'camunda:In') && !this.canHostIn(parent)) {\n    return false;\n  }\n};\n\nCopyPasteBehavior.prototype.canHostInputOutput = function(parent) {\n\n  // allowed in camunda:Connector\n  var connector = getParent(parent, 'camunda:Connector');\n\n  if (connector) {\n    return true;\n  }\n\n  // special rules inside bpmn:FlowNode\n  var flowNode = getParent(parent, 'bpmn:FlowNode');\n\n  if (!flowNode) {\n    return false;\n  }\n\n  if (isAny(flowNode, [ 'bpmn:StartEvent', 'bpmn:Gateway', 'bpmn:BoundaryEvent' ])) {\n    return false;\n  }\n\n  if (is(flowNode, 'bpmn:SubProcess') && flowNode.get('triggeredByEvent')) {\n    return false;\n  }\n\n  return true;\n};\n\nCopyPasteBehavior.prototype.canHostConnector = function(parent) {\n\n  var serviceTaskLike = getParent(parent, 'camunda:ServiceTaskLike');\n\n  if (is(serviceTaskLike, 'bpmn:MessageEventDefinition')) {\n\n    // only allow on throw and end events\n    return (\n      getParent(parent, 'bpmn:IntermediateThrowEvent') ||\n      getParent(parent, 'bpmn:EndEvent')\n    );\n  }\n\n  return true;\n};\n\nCopyPasteBehavior.prototype.canHostIn = function(parent) {\n\n  var callActivity = getParent(parent, 'bpmn:CallActivity');\n\n  if (callActivity) {\n    return true;\n  }\n\n  var signalEventDefinition = getParent(parent, 'bpmn:SignalEventDefinition');\n\n  if (signalEventDefinition) {\n\n    // only allow on throw and end events\n    return (\n      getParent(parent, 'bpmn:IntermediateThrowEvent') ||\n      getParent(parent, 'bpmn:EndEvent')\n    );\n  }\n\n  return true;\n};\n\nmodule.exports = CopyPasteBehavior;\n\n// helpers //////////\n\nfunction is(element, type) {\n  return element && isFunction(element.$instanceOf) && element.$instanceOf(type);\n}\n\nfunction isAny(element, types) {\n  return some(types, function(t) {\n    return is(element, t);\n  });\n}\n\nfunction getParent(element, type) {\n  if (!type) {\n    return element.$parent;\n  }\n\n  if (is(element, type)) {\n    return element;\n  }\n\n  if (!element.$parent) {\n    return;\n  }\n\n  return getParent(element.$parent, type);\n}\n\nfunction isAllowedInParent(property, parent) {\n\n  // (1) find property descriptor\n  var descriptor = property.$type && property.$model.getTypeDescriptor(property.$type);\n\n  var allowedIn = descriptor && descriptor.meta && descriptor.meta.allowedIn;\n\n  if (!allowedIn || isWildcard(allowedIn)) {\n    return true;\n  }\n\n  // (2) check wether property has parent of allowed type\n  return some(allowedIn, function(type) {\n    return getParent(parent, type);\n  });\n}\n\nfunction isWildcard(allowedIn) {\n  return allowedIn.indexOf(WILDCARD) !== -1;\n}","'use strict';\n\nvar inherits = require('inherits');\n\nvar find = require('min-dash').find,\n    matchPattern = require('min-dash').matchPattern;\n\nvar CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor').default;\n\nvar collectionAdd = require('diagram-js/lib/util/Collections').add,\n    collectionRemove = require('diagram-js/lib/util/Collections').remove;\n\nvar getBusinessObject = require('bpmn-js/lib/util/ModelUtil').getBusinessObject,\n    is = require('bpmn-js/lib/util/ModelUtil').is;\n\nvar LOW_PRIORITY = 500;\n\n\n/**\n * Add referenced root elements (bpmn:Error) if they don't exist.\n * Copy referenced root elements on copy & paste.\n */\nfunction CopyPasteRootElementBehavior(\n    bpmnjs, eventBus, injector, moddleCopy, bpmnFactory\n) {\n\n  injector.invoke(CommandInterceptor, this);\n\n\n  function hasRootElement(rootElement) {\n    var definitions = bpmnjs.getDefinitions(),\n        rootElements = definitions.get('rootElements');\n\n    return !!find(rootElements, matchPattern({ id: rootElement.id }));\n  }\n\n\n  // create shape\n  this.executed('shape.create', function(context) {\n\n    var shape = context.shape,\n        businessObject = getBusinessObject(shape);\n\n    if (!canHaveNestedRootElementReference(businessObject)) {\n      return;\n    }\n\n    var referencedRootElements = getRootElements(businessObject, getReferencingElement(shape)),\n        rootElements = bpmnjs.getDefinitions().get('rootElements');\n\n    context.addedRootElements = [];\n\n    referencedRootElements.forEach(function(reference) {\n      var element = reference.referencedElement;\n\n      if (element && !hasRootElement(element)) {\n\n        // add root element\n        collectionAdd(rootElements, element);\n\n        context.addedRootElements.push(element);\n      }\n    });\n  }, true);\n\n  this.reverted('shape.create', function(context) {\n    var addedRootElements = context.addedRootElements;\n\n    if (!addedRootElements) {\n      return;\n    }\n\n    var rootElements = bpmnjs.getDefinitions().get('rootElements');\n\n    // remove root elements\n    addedRootElements.forEach(function(addedRootElement) {\n      collectionRemove(rootElements, addedRootElement);\n    });\n  }, true);\n\n  eventBus.on('copyPaste.copyElement', function(context) {\n    var descriptor = context.descriptor,\n        element = context.element,\n        businessObject = getBusinessObject(element);\n\n    if (!canHaveNestedRootElementReference(businessObject)) {\n      return;\n    }\n\n    var rootElements = getRootElements(businessObject, getReferencingElement(element));\n\n    if (rootElements) {\n      descriptor.referencedRootElements = rootElements;\n    }\n  });\n\n\n  eventBus.on('copyPaste.pasteElement', LOW_PRIORITY, function(context) {\n    var descriptor = context.descriptor,\n        businessObject = descriptor.businessObject;\n\n    if (!canHaveNestedRootElementReference(businessObject)) {\n      return;\n    }\n\n    var referencedRootElements = descriptor.referencedRootElements;\n\n    if (referencedRootElements && referencedRootElements.length) {\n\n      referencedRootElements.forEach(function(reference) {\n\n        var element = reference.referencedElement,\n            idx = reference.idx;\n\n        if (!element) {\n          return;\n        }\n\n        if (!hasRootElement(element)) {\n          element = moddleCopy.copyElement(\n            element,\n            bpmnFactory.create(element.$type)\n          );\n        }\n\n        setRootElement(businessObject, element, idx);\n      });\n    }\n\n    delete descriptor.referencedRootElements;\n  });\n}\n\nCopyPasteRootElementBehavior.$inject = [\n  'bpmnjs',\n  'eventBus',\n  'injector',\n  'moddleCopy',\n  'bpmnFactory'\n];\n\ninherits(CopyPasteRootElementBehavior, CommandInterceptor);\n\nmodule.exports = CopyPasteRootElementBehavior;\n\n\n// helpers //////////////////////////\n\nfunction getReferencingElement(element) {\n  if (is(element, 'bpmn:ServiceTask')) {\n    return 'camunda:ErrorEventDefinition';\n  }\n}\n\nfunction getRootElementReferencePropertyName(bo) {\n  if (is(bo, 'camunda:ErrorEventDefinition')) {\n    return 'errorRef';\n  }\n}\n\nfunction canHaveNestedRootElementReference(bo) {\n  var isExternalServiceTask = is(bo, 'bpmn:ServiceTask') && bo.type === 'external';\n  return isExternalServiceTask;\n}\n\n/**\n * Retrieves a list of to-be copied references for the extension elements\n * of a given element in the following form\n *\n * [\n *  {\n *    idx: 0, // position of extension in the list of extension elements\n *    referencedElement: {ModdleElement} // reference to root element\n *  }\n * ]\n *\n *\n * @param {ModdleElement} bo\n * @param {String} extensionElementType\n *\n * @returns {Array}\n */\nfunction getRootElements(bo, extensionElementType) {\n  var extensionElements = bo.get('extensionElements'),\n      filteredExtensionElements = [],\n      rootElementReference;\n\n  if (extensionElements) {\n    filteredExtensionElements = extensionElements.values.filter(function(element) {\n      return is(element, extensionElementType);\n    });\n  }\n\n  var rootElements = filteredExtensionElements.reduce(function(result, element) {\n\n    rootElementReference = element[getRootElementReferencePropertyName(element)];\n\n    if (rootElementReference) {\n      result.push({\n        idx: findExtensionElement(bo, element),\n        referencedElement: rootElementReference\n      });\n    }\n\n    return result;\n  }, []);\n\n  return rootElements;\n}\n\nfunction setRootElement(bo, rootElement, index) {\n  var extensionElement = bo.get('extensionElements').values[index];\n\n  extensionElement.set(getRootElementReferencePropertyName(extensionElement), rootElement);\n}\n\nfunction findExtensionElement(bo, extensionElement) {\n  var extensionElements = bo.get('extensionElements');\n\n  if (!extensionElements) {\n    return -1;\n  }\n\n  return extensionElements.values.indexOf(extensionElement);\n}\n","'use strict';\n\nvar inherits = require('inherits');\n\nvar CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor').default;\nvar is = require('bpmn-js/lib/util/ModelUtil').is;\nvar getBusinessObject = require('bpmn-js/lib/util/ModelUtil').getBusinessObject;\n\n/**\n * Remove `camunda:initiator` property when a startEvent is moved to or created within a subProcess.\n */\nfunction RemoveInitiatorBehaviour(\n    modeling, injector\n) {\n\n  injector.invoke(CommandInterceptor, this);\n\n  this.postExecuted(['shape.create','shape.move'], function(context) {\n\n    var shape = context.shape,\n        newParent = context.newParent || context.parent,\n        businessObject = getBusinessObject(shape);\n\n    // if shape is a startEvent and has an initiator proterty\n    if (is(shape, 'bpmn:StartEvent') && businessObject.get('camunda:initiator') !== undefined) {\n\n      // if subProcess becomes the new parent\n      if ((is(newParent, 'bpmn:SubProcess'))) {\n\n        // remove initiator property\n        modeling.updateProperties(shape, { 'camunda:initiator': undefined });\n\n      }\n    }\n\n  }, true);\n}\n\nRemoveInitiatorBehaviour.$inject = [\n  'modeling',\n  'injector',\n];\n\ninherits(RemoveInitiatorBehaviour, CommandInterceptor);\n\nmodule.exports = RemoveInitiatorBehaviour;\n","'use strict';\n\nvar inherits = require('inherits');\n\nvar CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor').default;\nvar is = require('bpmn-js/lib/util/ModelUtil').is;\nvar getBusinessObject = require('bpmn-js/lib/util/ModelUtil').getBusinessObject;\n\n/**\n * Remove 'camunda:variableEvents' property when a startEvent is moved out of an event subProcess.\n */\nfunction RemoveVariableEventBehaviour(\n    modeling, injector, bpmnFactory, moddleCopy\n) {\n  injector.invoke(CommandInterceptor, this);\n\n  this.postExecuted(['shape.move', 'shape.create'], function(context) {\n\n    var newParent = context.newParent || context.parent,\n        newParentBusinessObject = getBusinessObject(newParent),\n        shape = context.shape,\n        shapeBusinessObject = getBusinessObject(shape),\n        eventDefinitions, definitionsCopy;\n\n    var update = false;\n\n    if (is(shape, 'bpmn:StartEvent')) {\n\n      if (!(is(newParent, 'bpmn:SubProcess') && newParentBusinessObject.get('triggeredByEvent'))) {\n\n        eventDefinitions = shapeBusinessObject.get('eventDefinitions');\n        definitionsCopy = eventDefinitions.slice();\n\n        definitionsCopy.forEach(function(eventDefinition, index) {\n          if (!is(eventDefinition, 'bpmn:ConditionalEventDefinition')) {\n            return;\n          }\n\n          if (eventDefinition.get('camunda:variableEvents')) {\n            update = true;\n\n            var newDefinition = bpmnFactory.create('bpmn:ConditionalEventDefinition');\n            moddleCopy.copyElement(eventDefinition, newDefinition);\n            newDefinition.$parent = eventDefinition.$parent;\n\n            // remove variableEvents property\n            newDefinition.variableEvents = undefined;\n            definitionsCopy[index] = newDefinition;\n          }\n        });\n\n        if (update) {\n          modeling.updateProperties(shape, { 'eventDefinitions': definitionsCopy });\n        }\n      }\n    }\n  }, true);\n}\n\nRemoveVariableEventBehaviour.$inject = [\n  'modeling',\n  'injector',\n  'bpmnFactory',\n  'moddleCopy'\n];\n\ninherits(RemoveVariableEventBehaviour, CommandInterceptor);\n\nmodule.exports = RemoveVariableEventBehaviour;\n"],"sourceRoot":""}